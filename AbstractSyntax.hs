module AbstractSyntax where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program = Program [Stmt]
  deriving (Eq, Ord, Show, Read)

data Stmt
    = SExp Exp
    | SAssign Exp Exp
    | SAddAssign Exp Exp
    | SSubAssign Exp Exp
    | SMulAssign Exp Exp
    | SDivAssign Exp Exp
    | SPass
    | SReturn
    | SReturnVal Exp
    | SBreak
    | SContinue
    | SPrint Exp
    | SIf Exp [Stmt] [Elif]
    | SIfElse Exp [Stmt] [Elif] [Stmt]
    | SWhile Exp [Stmt]
    | SVarDef Type Ident Exp
    | SFuncDef Type Ident [VarDecl] [Stmt]
  deriving (Eq, Ord, Show, Read)

data Elif = Elif Exp [Stmt]
  deriving (Eq, Ord, Show, Read)

data Exp
    = ELambda Type [VarDecl] Exp
    | EOr Exp Exp
    | EAnd Exp Exp
    | ENot Exp
    | EEq Exp Exp
    | ENeq Exp Exp
    | ELt Exp Exp
    | ELeq Exp Exp
    | EGt Exp Exp
    | EGeq Exp Exp
    | EAdd Exp Exp
    | ESub Exp Exp
    | EMul Exp Exp
    | EDiv Exp Exp
    | EPlus Exp
    | EMinus Exp
    | EVar Ident
    | EInt Integer
    | ETrue
    | EFalse
    | EArray [Exp]
    | EFill Exp Integer
    | ECall Exp [Exp]
    | EIndex Exp Exp
  deriving (Eq, Ord, Show, Read)

data Type
    = TVoid
    | TInt
    | TBool
    | TArray Type Integer
    | TFunc Type [Type]
    | TRef Type
  deriving (Eq, Ord, Show, Read)

data VarDecl = VarDecl Type Ident
  deriving (Eq, Ord, Show, Read)


isVoidType :: Type -> Bool
isVoidType TVoid = True
isVoidType _ = False

isRefType :: Type -> Bool
isRefType (TRef _) = True
isRefType _ = False

isFuncType :: Type -> Bool
isFuncType (TFunc _ _) = True
isFuncType _ = False
